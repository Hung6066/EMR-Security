Tài liệu Kiến trúc Bảo mật Hệ thống Bệnh án Điện tử (EMR)
Phiên bản: 1.0
Ngày: 24/05/2024
Đối tượng: Kiến trúc sư, Lập trình viên, Quản trị viên hệ thống, Chuyên viên An ninh thông tin.

1. Giới thiệu và Triết lý Bảo mật
1.1. Mục tiêu
Tài liệu này mô tả kiến trúc bảo mật đa lớp (Defense-in-Depth) được thiết kế và triển khai cho hệ thống EMR. Mục tiêu là xây dựng một hệ thống không chỉ mạnh mẽ về mặt chức năng mà còn đạt và vượt các tiêu chuẩn bảo mật quốc tế nghiêm ngặt nhất trong ngành y tế (như HIPAA), đảm bảo tính Bí mật (Confidentiality), Toàn vẹn (Integrity), và Sẵn sàng (Availability) của dữ liệu bệnh nhân.

1.2. Triết lý Bảo mật
Kiến trúc được xây dựng dựa trên các nguyên tắc cốt lõi:

Defense-in-Depth: Không tin tưởng vào một lớp bảo vệ duy nhất. Hệ thống được xây dựng với nhiều lớp phòng thủ độc lập, nếu một lớp bị xuyên thủng, các lớp khác sẽ ngăn chặn cuộc tấn công.
Zero Trust (Không tin cậy bất kỳ ai): Mọi yêu cầu, dù từ bên trong hay bên ngoài mạng, đều phải được xác thực, ủy quyền và kiểm tra trước khi được cấp quyền truy cập. "Never trust, always verify."
Principle of Least Privilege (Nguyên tắc Đặc quyền Tối thiểu): Mỗi người dùng và dịch vụ chỉ được cấp quyền tối thiểu cần thiết để thực hiện công việc của mình.
Secure by Design & Default: Bảo mật được tích hợp ngay từ khâu thiết kế, không phải là một tính năng "thêm vào sau". Các cài đặt mặc định luôn là cài đặt an toàn nhất.
Automation & Orchestration: Tự động hóa việc phát hiện, phản ứng và khắc phục sự cố để giảm thiểu thời gian phản ứng và sai sót của con người.
2. Các Lớp Bảo mật (Security Layers)
Hệ thống được bảo vệ bởi các lớp tuần tự, từ ngoài vào trong và từ tầng hạ tầng lên tầng ứng dụng.

Lớp 1: Kiểm soát Truy cập & Nhận dạng (Identity & Access Management)
Lớp này là cửa ngõ đầu tiên, đảm bảo "đúng người" được vào hệ thống.

Xác thực Mạnh & Đa yếu tố (MFA):

Cách vận hành: Ngoài mật khẩu, người dùng bắt buộc phải cung cấp một yếu tố xác thực thứ hai. Hệ thống hỗ trợ:
TOTP (Time-based One-Time Password): Dùng ứng dụng Authenticator (Google, Microsoft, Authy) để quét mã QR và nhận mã 6 số thay đổi mỗi 30 giây.
WebAuthn/FIDO2 (Sinh trắc học): Cho phép đăng nhập không mật khẩu bằng vân tay, khuôn mặt, hoặc khóa bảo mật vật lý (YubiKey). Đây là tiêu chuẩn chống phishing mạnh nhất.
Thành phần: ITwoFactorService, IWebAuthnService, các controller và component tương ứng.
Quản lý Chính sách Mật khẩu Động (Password Policy Management):

Cách vận hành: Admin có thể cấu hình động các yêu cầu về mật khẩu mà không cần deploy lại code.
Độ phức tạp: Độ dài, chữ hoa/thường, số, ký tự đặc biệt.
Lịch sử: Ngăn người dùng sử dụng lại N mật khẩu cũ.
Hết hạn: Bắt buộc đổi mật khẩu sau X ngày.
Kiểm tra lộ lọt: Tích hợp API của "Have I Been Pwned" để tự động từ chối các mật khẩu đã từng xuất hiện trong các vụ rò rỉ dữ liệu lớn.
Thành phần: PasswordPolicyController, IPasswordPolicyService, CustomPasswordValidator.
Quản lý Phiên & Thiết bị Tin cậy (Session & Trusted Device Management):

Cách vận hành: Mỗi lần đăng nhập thành công, một "phiên" được tạo và gắn với "dấu vân tay thiết bị" (Device Fingerprint).
Hệ thống ghi nhận các thiết bị người dùng thường xuyên sử dụng.
Người dùng có thể xem danh sách các thiết bị đang đăng nhập và đăng xuất từ xa khỏi một thiết bị đáng ngờ.
Đăng nhập từ một thiết bị hoàn toàn mới có thể kích hoạt các yêu cầu xác thực bổ sung.
Thành phần: SecurityController, IDeviceFingerprintService, TrustedDevicesComponent.
Phân quyền Chi tiết (Granular Authorization):

Cách vận hành: Sử dụng cơ chế Role-Based Access Control (RBAC) kết hợp với các Claim và Policy của .NET.
Roles: Admin, Security, Doctor, Nurse, Patient...
Policies: Các chính sách phức tạp hơn, ví dụ [Authorize(Policy = "DoctorOrNurse")].
Permissions (Claims): Các quyền chi tiết hơn như permission:ViewFullPII, permission:ExportReport được gán cho các vai trò và kiểm tra trong code.
Thành phần: Cấu hình trong Program.cs, các attribute [Authorize] trên Controller/Action.
Lớp 2: Bảo vệ Ứng dụng & API (Application & API Security)
Lớp này bảo vệ ứng dụng đang chạy khỏi các cuộc tấn công nhắm vào logic và giao diện.

Runtime Application Self-Protection (RASP):

Cách vận hành: Một middleware thông minh (RaspMiddleware) được đặt ở đầu pipeline request. Nó hoạt động như một "hệ miễn dịch" bên trong ứng dụng.
Phân tích Real-time: Tự động phân tích mọi request đến để tìm dấu hiệu của các cuộc tấn công phổ biến như SQL Injection, Cross-Site Scripting (XSS), Path Traversal.
Tự phản ứng: Nếu phát hiện mối đe dọa, nó sẽ ngay lập tức chặn request, ghi log chi tiết, tự động tạo sự cố trong hệ thống SOAR, và chặn IP của kẻ tấn công mà không cần can thiệp từ bên ngoài.
Thành phần: RaspMiddleware, tích hợp với ISecurityIncidentService và IThreatIntelligenceService.
Moving Target Defense (MTD):

Cách vận hành: Làm cho bề mặt tấn công của hệ thống liên tục thay đổi, gây khó khăn cho việc do thám tự động.
API Endpoint Rotation: Các đường dẫn API không cố định. Ví dụ /api/patients sẽ trở thành /api/rt-xxxx/patients, trong đó xxxx là một chuỗi được tạo ra hàng ngày dựa trên một secret key. Frontend sẽ tự tính toán và gọi đến đúng đường dẫn. Bất kỳ request nào đến đường dẫn cũ đều bị từ chối.
Just-in-Time Credentials: (Kiến trúc) Ứng dụng không lưu chuỗi kết nối database vĩnh viễn. Thay vào đó, nó yêu cầu một credential tạm thời từ một hệ thống quản lý bí mật (như HashiCorp Vault) khi khởi động. Credential này chỉ có hiệu lực trong thời gian ngắn và được tự động xoay vòng.
Thành phần: MtdMiddleware, ApiUrlService (Angular), tích hợp với Vault.
Deception Technology (Công nghệ Đánh lừa):

Cách vận hành: Tạo ra các "cạm bẫy" trong hệ thống. Bất kỳ tương tác nào với chúng đều là một cảnh báo an ninh nghiêm trọng.
Honey Tokens: Các bản ghi dữ liệu giả (bệnh nhân, bác sĩ, thuốc...) với ID đặc biệt. Logic trong các service sẽ kiểm tra nếu có ai đó truy vấn đến các ID này.
Honeypots: Các API endpoint giả, không được sử dụng (/wp-admin, /api/backup/download-all). Bất kỳ request nào đến đây đều được xác định là hành vi quét lỗ hổng.
Cách phản ứng: Khi bẫy được kích hoạt, hệ thống sẽ ngay lập tức tạo một sự cố Critical, chặn vĩnh viễn IP kẻ tấn công, và có thể đánh lạc hướng bằng cách trả về dữ liệu giả.
Thành phần: DeceptionService, HoneypotController, logic kiểm tra trong các service nghiệp vụ.
Security Headers, Rate Limiting & CAPTCHA:

Cách vận hành: Các cơ chế phòng thủ tiêu chuẩn nhưng cực kỳ hiệu quả.
Security Headers: Cấu hình CSP, HSTS, X-Frame-Options... để ngăn chặn các cuộc tấn công từ phía trình duyệt (SecurityHeadersMiddleware).
Rate Limiting: Giới hạn số lượng request từ một IP trong một khoảng thời gian nhất định, chống tấn công Brute Force và DoS (IpRateLimitingMiddleware).
CAPTCHA: Yêu cầu xác thực "tôi không phải robot" sau nhiều lần đăng nhập thất bại để chặn bot.
Thành phần: Middleware tương ứng, tích hợp ng-recaptcha ở frontend.
Lớp 3: Bảo vệ Dữ liệu (Data Protection)
Lớp này tập trung vào việc bảo vệ tài sản quý giá nhất: dữ liệu bệnh nhân.

Mã hóa Toàn diện (Encryption Everywhere):

At-Transit: Mọi giao tiếp giữa client và server, giữa các microservice đều phải dùng TLS 1.3.
At-Rest: Dữ liệu trong CSDL được mã hóa bằng Transparent Data Encryption (TDE) của SQL Server. Các file được mã hóa bằng mã hóa của hệ thống lưu trữ (ví dụ: SSE của S3/Azure Blob).
In-Use (Confidential Computing): Các xử lý dữ liệu nhạy cảm nhất (như phân tích AI trên bệnh án) được thực hiện trong một secure enclave. Dữ liệu được mã hóa ngay cả khi đang ở trong RAM, chống lại sự xâm nhập từ quản trị viên hệ thống hoặc lỗ hổng phần cứng.
Application-Level Encryption (ALE): Các trường dữ liệu cực kỳ nhạy cảm (như số CCCD) được mã hóa ngay tại tầng ứng dụng trước khi lưu vào CSDL, sử dụng AdvancedEncryptionService.
Quản lý Khóa & Vòng đời (Key Management & Rotation):

Cách vận hành: Hệ thống tự quản lý vòng đời của các khóa mã hóa.
Sử dụng một Master Key được lưu trữ an toàn (trong Azure Key Vault, AWS KMS) để mã hóa các khóa dữ liệu (Data Encryption Keys - DEK).
Các DEK được tạo ra với mục đích và thời gian sống cụ thể.
Hệ thống có cơ chế xoay vòng khóa (key rotation) tự động hoặc thủ công. Khi một khóa được xoay vòng, một khóa mới sẽ được tạo ra, và dữ liệu cũ có thể được mã hóa lại bằng khóa mới (chạy nền).
Thành phần: EncryptionDashboardComponent, IAdvancedEncryptionService.
Dynamic Data Masking & Obfuscation:

Cách vận hành: Dữ liệu nhạy cảm được tự động che đi (masking) ở tầng API trước khi trả về cho client, dựa trên quyền của người dùng.
Một JsonConverter tùy chỉnh (DataMaskingConverter) sẽ kiểm tra quyền permission:ViewFullPII của người dùng.
Nếu không có quyền, các trường được đánh dấu [DataMasking] trong DTO sẽ bị che (ví dụ: *********1234, n***@***.com).
Lợi ích: Đảm bảo nguyên tắc "need-to-know" và giảm thiểu rủi ro lộ dữ liệu trên giao diện người dùng.
Data Leakage Prevention (DLP) & Watermarking:

Cách vận hành:
DLP: Một middleware (DlpMiddleware) quét nội dung của tất cả các API response. Nếu phát hiện dữ liệu khớp với các pattern nhạy cảm (số thẻ tín dụng, CCCD...) trong các quy tắc DLP, nó sẽ tự động chặn hoặc che (redact) dữ liệu đó.
Watermarking: Mọi file PDF được xuất ra từ hệ thống (bệnh án, báo cáo) sẽ được tự động đóng một dấu chìm (watermark) chứa thông tin về người truy cập, thời gian, và địa chỉ IP, giúp truy vết nguồn gốc nếu file bị rò rỉ.
Thành phần: DlpMiddleware, IDlpService, cập nhật IPdfService.
Lớp 4: Giám sát, Phát hiện & Phản ứng (Monitoring, Detection & Response)
Lớp này đảm bảo chúng ta có "đôi mắt" để quan sát mọi thứ và khả năng phản ứng khi có sự cố.

Blockchain Audit Trail (Nhật ký Kiểm toán Bất biến):

Cách vận hành: Mọi hành động quan trọng (thay đổi bệnh án, cấp quyền, truy cập dữ liệu nhạy cảm) không chỉ được ghi vào AuditLog thông thường mà còn được tạo thành một "giao dịch" và đưa vào một chuỗi blockchain riêng tư.
Mỗi khối được liên kết với khối trước đó bằng hash và được "mine" (Proof of Work) để đảm bảo tính bất biến.
Hệ thống có cơ chế tự động xác thực toàn bộ chuỗi (Validate Chain) định kỳ để phát hiện bất kỳ sự giả mạo nào đối với lịch sử kiểm toán.
Lợi ích: Tạo ra một bằng chứng không thể chối cãi về mọi thay đổi trong hệ thống, đáp ứng yêu cầu cao nhất về tính toàn vẹn dữ liệu.
Thành phần: IBlockchainService, BlockchainExplorerComponent.
User and Entity Behavior Analytics (UEBA):

Cách vận hành: Đây là phiên bản nâng cao của phát hiện bất thường.
Học Baseline: Một background job (Hangfire) định kỳ phân tích AuditLog để "học" hành vi bình thường của mỗi người dùng: giờ làm việc quen thuộc, dải IP hay sử dụng, các loại hành động/tài nguyên thường truy cập.
Phát hiện Sai lệch: Khi có một hành động mới, hệ thống sẽ so sánh nó với baseline đã học. Nếu có sự sai lệch lớn (ví dụ: một bác sĩ đột nhiên đăng nhập lúc 3 giờ sáng từ một quốc gia lạ và xuất hàng loạt bệnh án), một UebaAlert sẽ được tạo ra với "Điểm Sai lệch" (Deviation Score).
Lợi ích: Phát hiện hiệu quả các mối đe dọa từ bên trong (insider threats) và các tài khoản bị chiếm đoạt.
Thành phần: IUebaService, UebaDashboardComponent.
Advanced Threat Hunting:

Cách vận hành: Cung cấp cho đội ngũ an ninh một "giao diện săn lùng" để chủ động tìm kiếm các mối đe dọa thay vì chờ cảnh báo.
Query Builder: Cho phép tạo các truy vấn phức tạp trên nhiều nguồn dữ liệu (AuditLog, LoginAttempts, ThreatLog). Ví dụ: "Tìm tất cả các user đã đăng nhập thất bại hơn 5 lần từ nhiều hơn 3 quốc gia trong 24 giờ qua".
IOC Management: Quản lý danh sách các Chỉ số Tấn công (Indicators of Compromise) như IP, domain, hash file độc hại. Hệ thống sẽ liên tục quét log để tìm sự trùng khớp.
Thành phần: IThreatHuntingService, ThreatHuntingComponent.
SOAR (Security Orchestration, Automation, and Response):

Cách vận hành: Đây là "bộ não" tự động hóa của trung tâm an ninh.
Khi một sự cố được tạo (từ RASP, UEBA, Honeypot...), SOAR sẽ tự động kích hoạt một "playbook" tương ứng.
Ví dụ Playbook "Tài khoản bị chiếm đoạt":
Enrich: Tự động lấy thông tin về IP đáng ngờ, kiểm tra lịch sử hành vi của người dùng.
Contain: Tự động chặn IP, đăng xuất tất cả các phiên của người dùng.
Notify: Gửi cảnh báo đến kênh Slack/Teams của đội an ninh với đầy đủ thông tin đã làm giàu.
Eradicate: Yêu cầu người dùng đổi mật khẩu và xác thực lại MFA trong lần đăng nhập tiếp theo.
Thành phần: ISoarService (workflow engine), tích hợp chặt chẽ với tất cả các service bảo mật khác.
Lớp 5: Bảo vệ Hạ tầng & Chuỗi Cung ứng (Infrastructure & Supply Chain Security)
Lớp này bảo vệ nền tảng mà ứng dụng đang chạy trên đó.

File Integrity Monitoring (FIM):

Cách vận hành: Một background job định kỳ quét tất cả các file quan trọng của ứng dụng (DLLs, appsettings.json, file trong wwwroot) và so sánh hash của chúng với một "baseline" (bản gốc) đã được lưu trữ.
Phát hiện: Bất kỳ sự thay đổi, thêm mới, hoặc xóa file nào không mong muốn đều sẽ bị phát hiện và cảnh báo ngay lập tức.
Lợi ích: Chống lại việc kẻ tấn công chèn mã độc hoặc thay đổi cấu hình trực tiếp trên máy chủ.
Thành phần: IFimService, FimComponent.
Code Attestation & Supply Chain Security:

Cách vận hành:
Trong CI/CD: Toàn bộ mã nguồn và các thư viện phụ thuộc (SBOM) được hash và ký số (code signing) trong pipeline build.
Khi khởi động: Ứng dụng tự kiểm tra chữ ký số của chính nó và xác thực hash của các file so với manifest đã được ký. Nếu có bất kỳ sự không khớp nào, ứng dụng sẽ từ chối khởi động và gửi cảnh báo nghiêm trọng.
Quét phụ thuộc: Tự động quét SBOM để tìm các thư viện có lỗ hổng đã biết.
Lợi ích: Đảm bảo mã nguồn đang chạy trên production chính xác là những gì đã được build và phê duyệt, chống lại các cuộc tấn công chuỗi cung ứng.
Thành phần: ICodeAttestationService, quy trình trong CI/CD.
3. Sơ đồ Luồng Vận hành Bảo mật Tổng thể
Một request của người dùng sẽ đi qua các lớp bảo vệ như sau:

text

[ User Request ]
       |
       v
[ WAF / External Firewall / CDN ] (Lớp ngoài cùng)
       |
       v
[ Web Server (Kestrel) ]
       |
       v
[ 1. Rate Limiting Middleware ] -> (Nếu vượt ngưỡng -> Block)
       |
       v
[ 2. RASP Middleware (Tự bảo vệ) ] -> (Nếu là tấn công -> Block, Tạo Incident, Chặn IP)
       |
       v
[ 3. Authentication Middleware (JWT/API Key) ] -> (Nếu không hợp lệ -> 401 Unauthorized)
       |
       v
[ 4. Zero Trust Middleware ]
       |  - Tính Trust Score (Device, Location, Behavior)
       |  - Đánh giá theo Policy
       |  -> (Nếu không đủ tin cậy -> 403 Forbidden, Yêu cầu MFA)
       v
[ 5. Controller Action ] -> [ 6. Application Service ]
       |                           |
       |                           - Logic nghiệp vụ
       |                           - Kiểm tra Honey Token
       |                           - Ghi Audit Log -> Kích hoạt UEBA phân tích
       v                           v
[ 7. Response Generation ]    [ Database (TDE, ALE) ]
       |
       v
[ 8. DLP Middleware ] -> (Quét response -> Nếu có rò rỉ -> Redact/Block)
       |
       v
[ User Response (Dữ liệu đã được bảo vệ) ]

---------------------------------------------------
[ BACKGROUND PROCESSES (Hangfire) ]
- UEBA Baseline Training
- FIM Scans
- Report Generation
- Certificate Transparency Monitoring